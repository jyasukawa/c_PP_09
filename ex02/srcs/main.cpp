#include "PmergeMe.hpp"

// Ford-Johnson merge-insertion sortとは、遅すぎて実用的ではないが比較の数を減らすことに関しては最もよく知られた比較ソートの 1 つ。
// これまでに知られている最良のアルゴリズムであるバイナリ挿入ソートとマージ ソート[1]よりも最悪の場合に使用する比較が少ない。
// このアルゴリズムは要素の順序を追跡するためにいくつかの特定のデータ構造を必要とする。
// 最小限の比較を実行するには、二分検索を最大限に活用する。
// 多くの挿入ベースの並べ替えアルゴリズムは二分検索を実行して要素を挿入する場所を見つける。

// マージ挿入ソートは、マージ ソートと挿入ソートを組み合わせたもので、n の値が小さい場合の最悪の場合の時間計算量を最小限に抑えます。
// 挿入ソートでは、指定された配列をソートされた部分とソートされていない部分に仮想的に分割します。その後、未ソート部分の各要素をソート済み部分の正しい位置に挿入します。
// 例: この配列を並べ替える場合: [5,4,3,2,4]
// 45324
// 34524　　　　　　　ひたすら隣同士を比較しながら挿入する
// 23454
// 23445

// マージソートでは、指定された配列を 2 つの部分に分割し、個別にソートしてから、ソートされた両方の半分をマージします。それは分割統治アルゴリズムに基づいています。
// 単一の要素だけが残るまで、指定された配列を 2 つの等しい半分に分割します。つまり、配列はそれ以上分割できません。
// マージソートを使用して、指定された配列 = [8,3,4,9,5,6] をソートする例を見てみましょう。
// 834 956
// 83 4    95 6
// 8 3 4    9 5 6
// 38 4    59 6
// 348 569　　　　　　　　　並べ替えしながらもどす！
// 345689

// Ford-Johnson マージ/挿入ソートは 3 段階のアルゴリズムであり、nをソートする要素の数とします
// １．コレクションをペアに分割し、これらの要素をペアごとに並べます。要素の数が奇数の場合、コレクションの最後の要素はどの要素ともペアになっていません。
// ２．要素のペアを最大値で再帰的に並べ替えます。（マージソート）要素の数が奇数の場合、最後の要素は最高値とみなされず、コレクションの最後に残されます。最も高い値がソートされたリストを形成し、これをメインチェーンと呼び、残りの要素は保留要素として知られる
// ３．ペンド要素をメインチェーンに挿入します。（バイナリ検索を使用した挿入ソート）最初の保留要素より小さいことがわかっています。これはメインチェーンの一部であるとみなされになります。ここで、挿入領域のサイズが可能な限りマイナスの累乗になるように、他の保留要素をメイン チェーンにに挿入します

// 比較の数を最小限に抑えながらメインチェーンに挿入する次のペンド要素の値は、実際には次のヤコブスタール数に対応します。最初に要素挿入したので、次はというようなります。
// 要約すると、メインチェーンへの最初の保留要素の挿入順序は次のとおりです: .𝑏1,𝑏3,𝑏2,𝑏5,𝑏4,𝑏11,𝑏10,𝑏9,𝑏8,𝑏7,𝑏6,...

// このアルゴリズムは、再帰呼び出しの前に実行される初期比較 (任意の項目をペアにして各ペアを比較) がmerge sortの初期比較と同じであるのに対し、再帰呼び出しの後に実行される比較はマージ挿入ソートと呼ばれます。 (バイナリ検索を使用して要素を 1 つずつソートされたリストに挿入する) は、挿入 sortと同じ原理に従います。この意味で、これはマージ ソートと挿入ソートの両方を組み合わせたハイブリッド アルゴリズムです。 



// マージ挿入ソートを使用する場合、vectorとlistのどちらが速いかは、使用するデータ構造や操作に依存します。一般的には、次のような点に注意する必要があります。

// データの挿入および削除操作:

// Vector: 要素の挿入や削除は、特定の位置以降の要素を移動する必要があります。これにはO(n)の時間がかかります。
// List: 要素の挿入や削除は、ポインタの更新だけで済むため、O(1)の時間で行えます。
// メモリ配置:

// Vector: メモリ上で連続した領域に要素が配置されます。これにより、要素へのランダムアクセスが高速に行えます。
// List: 各要素はポインタで接続されており、メモリ上で非連続の領域に配置されます。ランダムアクセスは遅くなりますが、挿入や削除が効率的です。
// アルゴリズムの特性:

// マージ挿入ソートは、要素を分割して再帰的にソートし、それらをマージするアルゴリズムです。この際、挿入ソートが効果的に利用されます。
// マージ操作では、連続したメモリ配置を活かすため、vectorの方が効率的に行えることがあります。
// したがって、マージ挿入ソートの場合、データの挿入や削除が頻繁に行われる場合はlistが速くなりますが、マージ操作が主要な処理であり、ランダムアクセスが必要な場合はvectorが速くなることがあります。データの特性や使用する操作に応じて、適切なデータ構造を選択することが重要です。



int	main(int argc, char **argv)
{
	if (argc < 2)
	{
		std::cout << "Error: Please enter arguments." << std::endl;
		return (1);
	}

	try
	{
		PmergeMe instance(argv + 1);//./PmergeMe以降を代入 +1と動かしているためconst char**とはできない
		instance.run();
	}
	catch(const std::exception &e)
	{
		std::cout << e.what() << std::endl;
		return (1);
	}

	return (0);
}

// ./PmergeMe `jot -r 3000 1 1000 | tr "\n" " "`
// ./PmergeMe $(jot -r 3000 1 1000 | tr "\n" " ")